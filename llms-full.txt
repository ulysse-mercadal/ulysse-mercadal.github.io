# R-Type



***

Welcome to the **R-Type** project documentation!
This documentation covers the three core components of our implementation:

* **3D Engine**: Responsible for rendering and scene management.
* **Network Protocol**: Handles communication between clients and server.
* **Game Engine**: Orchestrates game logic, entities, and systems.

<Cards>
  <Card title="3D Engine" href="3d-engine/00-introduction" description="Learn about our custom C++ 3D rendering engine using OpenGL, Assimp, and GLM." />

  <Card title="Network Protocol" href="network-protocol/00-introduction" description="Documentation of the custom UDP/TCP-based protocol for real-time multiplayer." />

  <Card title="RFC Documentation" href="network-protocol/RFC/documentation" description="The full RFC formated documentation of the R-Type protocol" />

  <Card title="Game Engine" href="game-engine/00-introduction" description="Discover ou custom ECS. Controlling core game logic, entity-component system, and gameplay rules." />
</Cards>


# 3D Engine Overview



***

Our custom C++ 3D engine is built for real-time rendering in game-like applications. It emphasizes **modularity**, **debuggability**, and **cross-platform compatibility** (currently Linux-focused, but with Windows supported).

## Core Dependencies

* **[OpenGL 4.6+](https://www.khronos.org/opengl/)** â€“ Programmable rendering pipeline
* **[GLM](https://github.com/g-truc/glm)** â€“ Mathematics (vectors, matrices, quaternions)
* **[Assimp](https://www.assimp.org/)** â€“ Model parsing (`.fbx`, `.obj`; `.glTF` planned)
* **[stb\_image](https://github.com/nothings/stb)** â€“ Texture loading (PNG, JPG, TGA, etc.)
* **[GLFW](https://www.glfw.org/) + [GLEW](http://glew.sourceforge.net/)** â€“ Window creation and OpenGL context/extension management
* **[CMake](https://cmake.org/)** â€“ Build system (Linux-native workflow with `FetchContent`)

To compile the game engine, just use our CMake, it will fetch our Dependencies by itself

***

## Key Features

* Entity-based scene graph (`GameObject` system)
* Full transform control (position, rotation, scale)
* Shader pipeline with uniform binding abstraction
* Skeletal animation support (`.FBX` only, `.GLTF` in the future)
* Material and texture system with debug validation
* Scene-level resource management


# Setup viewport



The 3D engine follows a standard **init -> update -> render** loop. These three methods form the backbone of the rendering pipeline.

***

## `initialize()`

```cpp
bool Renderer3D::initialize();
```

### Purpose

Initializes all subsystems required for rendering:

* OpenGL context (via GLEW),
* Built-in shaders (`simple`, `phong`, `pixelize`),
* Framebuffer pipeline,
* OpenGL render states (depth test, culling, blending).

### Usage

Call **once** at application startup, after OpenGL context creation.

```cpp
Renderer3D renderer;
if (!renderer.initialize()) {
    // handle initialization errors
}
```

### Return Value

* `true` on success,
* `false` if any subsystem fails (e.g., shader compilation error).

> Must be called before `addObject()`, `update()`, or `render()` it should be the **FIRST** thing happening in the viewport setup.

***

## `update()`

```cpp
void Renderer3D::update(const Camera& camera, float width, float height);
```

### Purpose

Prepares the scene for rendering by:

1. Updating skeletal animations (using delta time),
2. Rebuilding the list of visible objects (`_renderBatches`),
3. Performing frustum culling (based on camera view),
4. Sorting opaque and transparent objects,
5. Computing view and projection matrices.

### Parameters

* `camera`: Contains position and orientation (see camera documentation page for more info).
* `width`, `height`: Viewport dimensions (used for aspect ratio in projection matrix).

### Usage

Call **once per frame**, before `render()`.

```cpp
Camera cam;
// ... update camera position ...
renderer.update(cam, windowWidth, windowHeight);
```

> Internally computes delta time using `std::chrono` for smooth animation.

***

## `render()`

```cpp
void Renderer3D::render(const Camera& camera);
```

### Purpose

Draws the scene using the current render batches and active shader(s). Supports:

* Single-pass rendering (with `_currentShader`),
* Multi-pass post-processing pipeline (via `_shaderPipeline`),
* Transparent object blending (sorted back-to-front),
* Skeletal animation (bone matrices uploaded per batch).

### Behavior

1. Binds framebuffers if a shader pipeline is active,
2. Renders geometry with correct materials and transforms,
3. Applies post-processing passes (e.g., pixelation) via full-screen quads,
4. Resets OpenGL state (`glBindVertexArray(0)`, `glUseProgram(0)`, etc.).

### Usage

Call **once per frame**, immediately after `update()`.

```cpp
renderer.render(cam);
```

> If `_shaderPipeline` is empty, uses `_currentShader`.

> Transparent materials are rendered after opaque ones with depth masking disabled.

***

## Typical Frame Loop

```cpp
// Initialization (once)
Renderer3D renderer;
renderer.initialize();
int objId = renderer.addObject("assets/indien-qui-danse.fbx");

// Per-frame loop
while (window.isOpen()) {
    glViewport(0, 0, windowSize.x, windowSize.y);

    Camera cam = getPlayerCamera();
    int width = window.getSize().x;
    int height = window.getSize().y;

    renderer.update(camera, windowSize.x, windowSize.y);      // â† Prepare batches + animations
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    renderer.render(camera);                                  // â† Draw everything
    window.pushGLStates();
    sf::View sfmlView = window.getDefaultView();
    window.setView(sfmlView);
    window.draw(centerDot);
    window.popGLStates();
    window.display();
}
```

> The engine **does not manage the window or input** â€” it only handles 3D rendering logic.

using SFML you should create the window as it follows

```cpp
sf::ContextSettings settings;
settings.depthBits = 24;
settings.stencilBits = 8;
settings.antialiasingLevel = 4;

sf::RenderWindow window;
window.create(sf::VideoMode(1920, 1080), "RTYPE - 3d engine", sf::Style::Default, settings);
window.setFramerateLimit(60);
window.setVerticalSyncEnabled(true);
window.setActive(true);

glEnable(GL_DEPTH_TEST);
glDisable(GL_CULL_FACE);
glClearColor(0.2f, 0.2f, 0.4f, 1.0f);   // purplish color
```


# Camera managment



The `Camera` class provides a navigation system with movement and rotation controls. It maintains position, orientation (yaw/pitch), and computes the view matrix for rendering.

## Core Interface

### Movement

```cpp
void Camera::move(float forward, float right, float up, float speed);
```

Moves the camera in local space:

* `forward`: +1 = move forward (along camera look direction)
* `right`: +1 = strafe right (perpendicular to look and up)
* `up`: +1 = move upward (world Y-axis)
* `speed`: scalar multiplier (e.g., `0.1f` per frame)

> Movement respects current rotation pressing key binded to the forward + 1 always moves in the direction the camera is facing.

### Rotation

```cpp
void Camera::rotate(float pitchDelta, float yawDelta);
```

Rotates the camera using Euler angles:

* `pitchDelta`: vertical rotation (in **degrees**), clamped to 89
* `yawDelta`: horizontal rotation (in **degrees**), unbounded (360 wrap)

> Rotation follows classic FPS behavior: mouse X -> yaw, mouse Y -> pitch.

***

## Usage Example (SFML Input)

```cpp
float speed = 0.1f;
float rotSpeed = 1.0f; // degrees per frame

// Movement (WASD + E/Q for vertical)
if (sf::Keyboard::isKeyPressed(sf::Keyboard::W))
    camera.move(1, 0, 0, speed);
if (sf::Keyboard::isKeyPressed(sf::Keyboard::S))
    camera.move(-1, 0, 0, speed);
if (sf::Keyboard::isKeyPressed(sf::Keyboard::A))
    camera.move(0, -1, 0, speed);
if (sf::Keyboard::isKeyPressed(sf::Keyboard::D))
    camera.move(0, 1, 0, speed);
if (sf::Keyboard::isKeyPressed(sf::Keyboard::E))
    camera.move(0, 0, 1, speed);
if (sf::Keyboard::isKeyPressed(sf::Keyboard::Q))
    camera.move(0, 0, -1, speed);

// Rotation (arrow keys)
if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right))
    camera.rotate(0, rotSpeed);      // yaw right
if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))
    camera.rotate(0, -rotSpeed);     // yaw left
if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down))
    camera.rotate(rotSpeed, 0);      // pitch down
if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up))
    camera.rotate(-rotSpeed, 0);     // pitch up
```

> **Note**: In a final game, you typically use **mouse delta** for rotation instead of arrow keys.

> yes this exemple is for a qwerty Keyboard, maybe because it's supperior to azerty for coding :)

***

## Accessing Camera State

```cpp
const glm::vec3& Camera::getPosition() const;
const glm::vec3& Camera::getFront() const;     // normalized look direction
const glm::vec3& Camera::getUp() const;        // world up (usually (0,1,0))
const glm::vec3& Camera::getRight() const;     // right vector (computed)

glm::mat4 Camera::getViewMatrix() const;       // ready for shader uniform
```

These are used internally by `Renderer3D::update()` and `render()`.

***

## Important Notes

* **Pitch is clamped** to \[-89, 89] to prevent gimbal lock and upside-down view.
* **Yaw is unbounded** it accumulates over time (e.g., 720 = two full turns).
* All rotation inputs are expected in **degrees**, not radians.

***

## Integration with Renderer

Pass the camera directly to the renderer each frame:

```cpp
renderer.update(camera, windowWidth, windowHeight);
renderer.render(camera);
```

The renderer uses `camera.getViewMatrix()` and `camera.getFront()` for culling and lighting.


# Add an object



Adds a 3D model to the scene and returns a unique instance ID for transformation, animation, or removal.

***

## Signature

```cpp
int Renderer3D::addObject(
    const std::string& modelPath,
    const glm::vec3& position = glm::vec3(0.0f),
    const glm::vec3& rotation = glm::vec3(0.0f),
    const glm::vec3& scale = glm::vec3(1.0f)
);
```

***

## Parameters

| Parameter   | Type                 | Description                                                                                 |
| ----------- | -------------------- | ------------------------------------------------------------------------------------------- |
| `modelPath` | `const std::string&` | Path to the model file (supports `.obj` and `.fbx`). Relative to the working directory.     |
| `position`  | `glm::vec3`          | World-space position of the object (default: origin).                                       |
| `rotation`  | `glm::vec3`          | Euler rotation in **radians** (XYZ or YXZ convention, depending on your `Transform` class). |
| `scale`     | `glm::vec3`          | Local scale (default: uniform scale of 1).                                                  |

> The rotation is applied as: `R = R_x * R_y * R_z` (intrinsic Tait-Bryan angles), consistent with your `Transform::getMatrix()` implementation.

***

## Return Value

* **`int`**: A non-negative instance ID if successful.
* **`-1`**: If the renderer is not initialized, the file extension is unsupported, or parsing fails.

> The ID is **per-model cache**, not globally unique across all models. It represents the index of the instance **within its model instance list**, to make it ecs compiliant you have to identify the object by it's cachekey (it's his file path) and his specific id.

***

## Behavior

1. **Caching**:
   If the model at `modelPath` has never been loaded, it is:
   * Parsed via `ObjParser` (`.obj`) or `FbxParser` (`.fbx`),
   * Converted into internal `Vertex`, `Material`, and (if animated) `Bone` data,
   * Uploaded to GPU (VAO/VBO),
   * Stored in an internal `Cache` keyed by path.

2. **Instancing**:
   A new `InstanceData` is appended to the cache instance list, containing:
   * The provided `Transform`,
   * A default `materialIndex` of `0`.

3. **Animation (FBX only)**:
   If the model has skinning (`model.hasSkinning == true`) and contains animations:
   * An `Animator` is created,
   * The **first animation** in the list is played automatically,
   * The animator is stored in `_animators` using the instance ID.

***

## Examples

### Load a static OBJ model

```cpp
int id = renderer.addObject(
    "assets/indien-qui-danse.fbx",
    {0, 0, -5});

if (id == -1) {
    // handle loading errors
}
```

### Load an animated FBX character

```cpp
int robotId = renderer.addObject(
    "assets/indien-qui-danse.fbx",
    {2.0f, 0.0f, -3.0f},
    {0.0f, glm::radians(90.0f), 0.0f}, // rotate to face camera
    {1.5f} // scale up
);
// If FBX contains animations, the first one starts playing automatically.
```

***

## See Also

* `removeAllObjects()` Clear all instances.
  ```cpp
  void removeAllObjects();
  ```

* `getObjectCount()` Get all object count in renderer
  ```cpp
  size_t getObjectCount() const;
  ```

> to see this object in the viewport you are must use at least one shader, learn more in the shader pipline doc page


# Transform an object



After creating an object with `addObject()`, you can dynamically update its position, rotation, or scale using the following public methods.

***

## Object Identification

Because object IDs are **local to each model**, you must always specify:

* `modelPath`: the exact path used in `addObject()` (e.g., `"assets/indien-qui-danse.fbx"`),
* `instanceId`: the integer returned by `addObject()`.

> The pair `(modelPath, instanceId)` uniquely identifies an instance.

***

## Available Methods

### `setObjectPosition`

Sets the world-space position of an instance.

```cpp
bool Renderer3D::setObjectPosition(
    const std::string& modelPath,
    int instanceId,
    const glm::vec3& position
);
```

**Example**:

```cpp
int id = renderer.addObject("assets/indien-qui-danse.fbx", {0,0,0});
renderer.setObjectPosition("assets/indien-qui-danse.fbx", id, {5.0f, 1.0f, -3.0f});
```

***

### `setObjectRotation`

Sets absolute Euler rotation in **radians** (YXZ convention).

```cpp
bool Renderer3D::setObjectRotation(
    const std::string& modelPath,
    int instanceId,
    const glm::vec3& rotation
);
```

**Example**:

```cpp
int id = renderer.addObject("assets/indien-qui-danse.fbx", {0,0,0});
renderer.setObjectRotation("assets/indien-qui-danse.fbx", id, {0.0f, glm::radians(90.0f), 0.0f});
```

***

### `setObjectScale`

Sets local scale per axis (or uniform if using `glm::vec3(s)`).

```cpp
bool Renderer3D::setObjectScale(
    const std::string& modelPath,
    int instanceId,
    const glm::vec3& scale
);
```

**Example**:

```cpp
int id = renderer.addObject("assets/indien-qui-danse.fbx", {0,0,0});
renderer.setObjectScale("assets/indien-qui-danse.fbx", id, glm::vec3(2.0f)); // uniform
renderer.setObjectScale("assets/indien-qui-danse.fbx", id, {1.0f, 2.0f, 0.5f}); // non-uniform
```

***

### `setObjectTransform`

Updates position, rotation, and scale in one call (more efficient).

```cpp
bool Renderer3D::setObjectTransform(
    const std::string& modelPath,
    int instanceId,
    const glm::vec3& position,
    const glm::vec3& rotation,
    const glm::vec3& scale
);
```

## Return Value

All methods return:

* `true` if the model and instance exist and the transform was updated,
* `false` if `modelPath` is not loaded or `instanceId` is out of bounds.

## Behavior Notes

* The new transform is applied **starting from the next frame** (used in `cullAndSortObjects`).
* Works **only on non-animated objects** (e.g., `.obj`). For skinned FBX models, vertex positions are driven by bone, these transforms are **ignored during animation**.

## Usage in Game Loop

```cpp
// In initialization
int playerModelId = renderer.addObject("assets/indien-qui-danse.fbx", {0,0,0});

// In update loop
glm::vec3 newPos = playerPosition + movementInput;
renderer.setObjectPosition("assets/indien-qui-danse.fbx", playerModelId, newPos);
```


# Shader pipline



The engine supports two rendering modes:

1. **Single-pass rendering** (using one active shader),
2. **Multi-pass post-processing pipeline** (chaining multiple shaders).

***

## Single Shader Mode (Default)

### `setCurrentShader(const std::string& shaderName)`

Sets the active shader for single-pass rendering.

```cpp
renderer.setCurrentShader("phong");
```

* Built-in shaders: `"simple"`, `"phong"`, `"pixelize"`.
* Must be called **before rendering** if not using a pipeline.
* Logs an error if the shader name is not found.

***

### `getCurrentShader() const`

Returns the currently active shader (used in single-pass mode).

```cpp
auto current = renderer.getCurrentShader();
if (current) {
    // e.g., modify uniforms manually
}
```

Returns `nullptr` if no shader is active.

***

### `getShader(const std::string& name) const`

Retrieves a loaded shader by name (without activating it).

```cpp
auto pixelShader = renderer.getShader("pixelize");
if () {
    // Add to pipeline later
}
```

***

## Shader Pipeline (Multi-Pass Post-Processing)

A **shader pipeline** is a sequence of shaders applied in order:

* **Pass 0**: Renders 3D geometry to an off-screen framebuffer.
* **Pass 1..N**: Each subsequent shader processes the output of the previous pass via a full-screen quad.

> Only the **last shader** renders to the screen. Others render to framebuffers.

### `addShaderToPipeline(std::shared_ptr<IShader> shader)`

Appends a shader to the end of the current pipeline.

```cpp
auto pixelShader = renderer.getShader("pixelize");
renderer.addShaderToPipeline(pixelShader);
```

> The first shader in the pipeline **must be a geometry shader** (e.g., `"phong"`). Post-processing shaders (e.g., `"pixelize"`) should come after.

***

### `setShaderPipeline(const std::vector<std::shared_ptr<IShader>>& pipeline)`

Replaces the entire pipeline at once.

```cpp
std::vector<std::shared_ptr<IShader>> pipeline = {
    renderer.getShader("phong"),
    renderer.getShader("pixelize")
};
renderer.setShaderPipeline(pipeline);
```

* Clears any existing pipeline.
* Automatically creates intermediate framebuffers.

***

### `getShaderPipeline() const`

Returns a reference to the current pipeline.

```cpp
const auto& pipeline = renderer.getShaderPipeline();
std::cout << "Pipeline length: " << pipeline.size() << "std::endl";
```

Useful for inspection or conditional logic.

***

### `removeShaderFromPipeline(const std::string& shaderName)`

Removes **all occurrences** of a shader (by name) from the pipeline.

```cpp
renderer.removeShaderFromPipeline("pixelize"); // disables pixelation
```

Does nothing if the shader is not in the pipeline.

***

### `clearShaderPipeline()`

Empties the entire pipeline.

```cpp
renderer.clearShaderPipeline(); // reverts to single-pass mode
```

After this, rendering uses `getCurrentShader()`.

***

## Rendering Behavior

| Pipeline State                 | Rendering Behavior                                                                                                          |
| ------------------------------ | --------------------------------------------------------------------------------------------------------------------------- |
| **Pipeline empty**             | Uses `getCurrentShader()` to render geometry directly to screen.                                                            |
| **Pipeline has N â‰¥ 1 shaders** | Renders geometry with `pipeline[0]` -> framebuffer,then applies `pipeline[1]` to `pipeline[N-1]` as post-processing passes. |

> The engine **automatically manages framebuffers** and texture bindings between passes.

***

## Example: Enable Pixelation Effect

```cpp
// Use Phong for lighting + Pixelize as post-process
renderer.setShaderPipeline({
    renderer.getShader("phong"),
    renderer.getShader("pixelize")
});
```

## Example: Toggle Post-Processing

```cpp
bool postEnabled = true;

if (sf::Keyboard::isKeyPressed(sf::Keyboard::P)) {
    if (postEnabled) {
        renderer.clearShaderPipeline();
    } else {
        renderer.setShaderPipeline({
            renderer.getShader("phong"),
            renderer.getShader("pixelize")
        });
    }
    postEnabled = !postEnabled;
}
```

> The `"simple"` shader is unlit and ignores materials â€” useful for debugging.
> The `"pixelize"` shader expects a `screenTexture` uniform (automatically bound by the engine).


# Animation



The engine supports **skeletal animation** for FBX models. Animations are managed per object instance and controlled via the `Renderer3D` interface.

> Only **FBX models** with embedded animation clips are supported. OBJ/MTL files do not support animation.

***

## Core Methods

### `playAnimation(int objectId, const std::string& animName, bool loop = true)`

Starts or switches to a named animation for a specific object instance.

```cpp
int robotId = renderer.addObject("assets/indien-qui-danse.fbx");
renderer.playAnimation(robotId, "Walk", true);
```

* `objectId`: The instance ID returned by `addObject()` (must correspond to an FBX model).
* `animName`: Exact name of the animation clip (case-sensitive).
* `loop`: If `true`, the animation restarts when it ends.

> If the animation name doesn't exist, nothing happens (no error is thrown).
> If the object is already playing an animation, it is **replaced immediately**.

***

### `toggleAnimationLooping(int objectId, bool enable)`

Enables or disables looping for the currently playing animation.

```cpp
renderer.toggleAnimationLooping(robotId, false); // play once
```

* Has no effect if no animation is playing on the object.

***

### `isAnimationLoopingEnabled(int objectId) const`

Returns whether the current animation is set to loop.

```cpp
if (renderer.isAnimationLoopingEnabled(robotId)) {
    // ...
}
```

***

### `getAnimationNames(int objectId) const`

Returns a list of all available animation names for the model used by this instance.

```cpp
std::vector<std::string> anims = renderer.getAnimationNames(robotId);
for (const auto& name : anims) {
    std::cout << "Available animation: " << name << "std::endl";
}
```

* Useful for UI or debugging.
* Returns an empty vector if:
  * The object doesn't exist,
  * The model has no animations,
  * The model is not FBX-based.

***

## Important Notes

### Object Identification

* `objectId` is the **instance index** returned by `addObject()` for a **specific model path**.
* Animations are only created **if the FBX model contains skinning and animation clips**.
* If you call `playAnimation` on a non-animated object (e.g., an `.obj`), it will **silently fail**.

### Animation Playback

* Time is tracked internally using **delta time** (from `std::chrono`).
* Only **one animation** can play per object at a time.
* Animation affects **vertex skinning** in the vertex shader via `uBones[]` uniforms.
* Transform changes (via `setObjectPosition`, etc.) **do not affect skinned meshes** the skeleton drives the geometry.

### Debug Tip

To verify animations are loaded:

```cpp
auto names = renderer.getAnimationNames(id);
assert(!names.empty()); // should list "Idle", "Walk", etc.
```

***

## Example: Animation Controller

```cpp
int characterId = renderer.addObject("assets/indien-qui-danse.fbx", {0,0,0});

// Play idle by default
renderer.playAnimation(characterId, "Idle", true);

// Switch based on input
if (isWalking) {
    renderer.playAnimation(characterId, "Walk", true);
} else if (isAttacking) {
    renderer.playAnimation(characterId, "Attack", false); // play once
    if (!renderer.isAnimationLoopingEnabled(characterId)) {
        // Optional: check if animation finished (not yet exposed)
    }
}
```

# Animation Control

The engine supports **skeletal animation** for FBX models. Animations are managed per object instance and controlled via the `Renderer3D` interface.

> ðŸ“Œ Only **FBX models** with embedded animation clips are supported. OBJ/MTL files do not support animation.

***

## Core Methods

### `playAnimation(int objectId, const std::string& animName, bool loop = true)`

Starts or switches to a named animation for a specific object instance.

```cpp
int robotId = renderer.addObject("assets/indien-qui-danse.fbx");
renderer.playAnimation(robotId, "Walk", true);
```

* `objectId`: The instance ID returned by `addObject()` (must correspond to an FBX model).
* `animName`: Exact name of the animation clip (case-sensitive).
* `loop`: If `true`, the animation restarts when it ends.

> If the animation name doesnâ€™t exist, nothing happens (no error is thrown).
> If the object is already playing an animation, it is **replaced immediately**.

***

### `toggleAnimationLooping(int objectId, bool enable)`

Enables or disables looping for the currently playing animation.

```cpp
renderer.toggleAnimationLooping(robotId, false); // play once
```

* Has no effect if no animation is playing on the object.

***

### `isAnimationLoopingEnabled(int objectId) const`

Returns whether the current animation is set to loop.

```cpp
if (renderer.isAnimationLoopingEnabled(robotId)) {
    // ...
}
```

***

### `getAnimationNames(int objectId) const`

Returns a list of all available animation names for the model used by this instance.

```cpp
std::vector<std::string> anims = renderer.getAnimationNames(robotId);
for (const auto& name : anims) {
    std::cout << "Available animation: " << name << "std::endl";
}
```

* Useful for UI or debugging.
* Returns an empty vector if:
  * The object doesnâ€™t exist,
  * The model has no animations,
  * The model is not FBX-based.

***

## Important Notes

### Object Identification

* `objectId` is the **instance index** returned by `addObject()` for a **specific model path**.
* Animations are only created **if the FBX model contains skinning and animation clips**.
* If you call `playAnimation` on a non-animated object (e.g., an `.obj`), it will **silently fail**.

### Animation Playback

* Time is tracked internally using **delta time** (from `std::chrono`).
* Only **one animation** can play per object at a time.
* Animation affects **vertex skinning** in the vertex shader via `uBones[]` uniforms.
* Transform changes (via `setObjectPosition`, etc.) **do not affect skinned meshes** â€” the skeleton drives the geometry.

***

## Example: Animation Controller

```cpp
int characterId = renderer.addObject("assets/indien-qui-danse.fbx", {0,0,0});

// Play idle by default
renderer.playAnimation(characterId, "Idle", true);

// Switch based on input
if (isWalking) {
    renderer.playAnimation(characterId, "Walk", true);
} else if (isAttacking) {
    renderer.playAnimation(characterId, "Attack", false); // play once
    if (!renderer.isAnimationLoopingEnabled(characterId)) {
        // Optional: check if animation finished (not yet exposed)
    }
}
```


# work in progress here



# Protocol Overview



***

# Introduction to the R-Type Protocol

The **R-Type Protocol** is a lightweight, modular network protocol designed to enable real-time multiplayer communication between a game client (specifically the **R-Type 3D** client) and a dedicated server.

***

## Goals

The protocol was built with the following key objectives:

* **Modularity & Reusability**: It is intentionally **decoupled from game logic**, making it adaptable to virtually any real-time multiplayer gameâ€”not just R-Type.
* **Performance**: To minimize latency, the protocol uses **TCP only for the initial connection handshake**, then switches to **UDP for all gameplay data**, ensuring fast and efficient transmission.
* **Bandwidth Efficiency**: Game data is packaged into compact binary **messages that may contain multiple commands** (e.g., movement + shooting + state change) in a single packet, reducing overall network overhead.

***

## Communication Flow

1. **Initial Connection (TCP)**
   The client establishes a TCP connection to the server to perform a secure **handshake**: exchanging version info, authentication tokens, and receiving a unique session ID.

2. **Gameplay Communication (UDP)**
   After the session is validated, all real-time gameplay updatesâ€”such as player input, entity states, and eventsâ€”are transmitted over **UDP**. This provides the low-latency responsiveness required for fast-paced action games.

3. **Multiplexed Packets**
   Each UDP packet can carry **one or more commands**. This batching mechanism optimizes bandwidth usage and reduces packet count, which is crucial for maintaining smooth synchronization under varying network conditions.

It contains **no hardcoded game logic**, allowing seamless integration into other game engines or genres (e.g., platformers, shooters, real-time strategy) with minimal adaptation.

***

## header and body

the command are split in two main parts the header and the body. the header contains information about the command, the sender, and the body size. the body contains the additional information (name, positions, status...)

This document serves as the foundation for the full R-Type Protocol specification. Subsequent sections will detail packet structures, supported command types, sequence numbering, and strategies for handling packet loss in UDP streams.


# Command list



***

# Protocol Commands

Each message in the R-Type Protocol is identified by an 8-bit **command ID**. The same ID may be used for related actions (e.g., client request and server broadcast), and the exact meaning is determined by the header. Below is the complete list of supported commands.

> * All commands respect the **512-byte packet limit**. Large payloads (e.g., long messages) must be split across multiple packets.

> * The same command ID is used for both **requests** and **notifications/responses**

| ID   | Name            | protocol | Description                                                                                |   Broadcast  |
| ---- | --------------- | :------: | ------------------------------------------------------------------------------------------ | :----------: |
| 0x00 | `CONNECTION`    |   `TCP`  | Initiates connection with the server.                                                      |     `no`     |
| 0x01 | `DISCONNECTION` |   `TCP`  | Signals disconnection from the server. may trigger a `LEAVE_LOBBY` if player in game       |     `no`     |
| 0x02 | `GET_LOBBY`     |   `TCP`  | Request or give all the existing lobby                                                     |     `no`     |
| 0x03 | `JOIN_LOBBY`    |   `TCP`  | Request or1 signal a new player in the lobby, The server replies with the new player list. |     `yes`    |
| 0x04 | `LEAVE_LOBBY`   |   `TCP`  | Request to leave the current lobby.                                                        |     `yes`    |
| 0x05 | `READY`         |   `TCP`  | Change a playerâ€™s readiness state in the lobby.                                            |     `yes`    |
| 0x06 | `START_GAME`    |   `TCP`  | Ask or notify the match is begining.                                                       |     `yes`    |
| 0x07 | `GAME_LOADED`   |   `TCP`  | Sent once local assets are loaded. Server waits before sending `GAME_START`.               |     `no`     |
| 0x08 | `GAME_START`    |   `TCP`  | Final signal from the server that the game loop is starting.                               |     `yes`    |
| 0x09 | `PAUSE`         |   `TCP`  | Update game pause state.                                                                   |     `yes`    |
| 0x0A | `WIN`           |   `TCP`  | Notifies victory                                                                           |     `yes`    |
| 0x0B | `LOSE`          |   `TCP`  | Notifies defeat                                                                            |     `yes`    |
| 0x0C | `DEAD`          |   `TCP`  | Notifies that a player or entity has been destroyed.                                       |     `yes`    |
| 0x0D | `INPUT`         |   `UDP`  | Reports a player input action, identified by a key for more modularity.                    |     `yes`    |
| 0x0E | `MOVE`          |   `UDP`  | Updates a playerâ€™s position in 3D space (`x, y, z`).                                       |     `yes`    |
| 0x0F | `SET_POSITION`  |   `UDP`  | Forces an absolute position update.                                                        |     `yes`    |
| 0x10 | `GET_COORDS`    |   `UDP`  | Requests current coordinates of an entity.                                                 |     `no`     |
| 0x11 | `PLAYER_INFO`   |   `UDP`  | Requests or give detailed player data                                                      | `no` / `yes` |
| 0x12 | `DAMAGE`        |   `UDP`  | Notifies that an entity has taken damage.                                                  |     `yes`    |
| 0x13 | `ABILITY`       |   `UDP`  | notify that a entity use one of his abilities.                                             |     `yes`    |
| 0x14 | `SCORE`         |   `UDP`  | Updates a playerâ€™s score.                                                                  |     `no`     |
| 0x15 | `MESSAGE`       |   `UDP`  | Sends a text message                                                                       |     `yes`    |


# Protocole limitations



***

## param size

* this ptococole can't have more than `255` **versions id**, because it's a `uint8`
* a server can't host more than `255` **players**, because it's a `uint8`
* a server can't host more than `255` **lobbys**, because it's a `uint8`
* a lobby can't host more than `255` **players**, because it's a `uint8`
* you can't handle more than `255` input **keys id**, because it's a `uint8`
* a **player name** must be a `string` with a length between `1`, and `20` chars
* a **lobby name** must be a `string` with a length between `1`, and `20` chars
* a level can't have more than `65534` **npcs** because it's a `uint16`
* a player can't take more than `65534`  **dammages** because it's a `uint16`


# Packet Structure



# Packet Structure

The R-Type Protocol uses a **uniform binary packet format** for **all communication**, whether sent over **TCP** (e.g., during handshake or reliable control messages) or **UDP** (for real-time gameplay updates). This ensures consistency across transport layers while allowing the protocol to remain transport-agnostic at the message level.

## General Rules

* **Maximum size per packet**: **512 bytes** (including header and body).
* A single packet may contain **one or more concatenated commands**.
* If the total data exceeds 512 bytes, it **must be split** into multiple packets.
* Each **command** is self-contained and consists of a **2-byte header** + an optional **body** (0 to 510 bytes).
* **command bodies are optional**: some commands have an empty body (`body length = 0`), while others carry structured game data.

> **Note**: Even during the **TCP handshake phase**, messages follow this exact format. The transport layer (TCP vs. UDP) affects delivery guarantees and latency, **not** the message encoding.

***

## command Format

Each command starts with a **2-byte (16-bit) header**, followed by a body whose length is declared in the header.

### Header Layout (2 bytes)

| Bits  | Field       | Description                                                                                 |
| ----- | ----------- | ------------------------------------------------------------------------------------------- |
| 15â€“14 | Direction   | 2-bit direction code (e.g., `00` = request, `01` = response â€” semantics defined by context) |
| 13â€“9  | command ID  | 5-bit unsigned integer (0â€“31) identifying the command type                                  |
| 8â€“0   | Body Length | 9-bit unsigned integer (0â€“511) indicating the size of the body **in bytes**                 |

> The **body length does not include** the 2-byte headerâ€¦ well because a header is not a body :)

#### Visual bit layout:

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |   | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| - | - | - | - | - | - | - | - | - | - | -- | -- | -- | -- | -- | -- | -- |
| D | D | I | I | I | I | I | L |   | L | L  | L  | L  | L  | L  | L  | L  |

> Where:
>
> * `D` = Direction (2 bits -> 4 possible values)
> * `I` = command ID (5 bits -> max 31)
> * `L` = Body length (9 bits -> max 511,)

***

## Usage Across Transports

| Transport | Typical Use Case                                            | Packet Handling                                                                                                                                  |
| --------- | ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| **TCP**   | Handshake, authentication, session setup, reliable commands | Packets are sent as a **stream**; the receiver must **frame** messages using the known 2-byte header + declared body length to delimit commands. |
| **UDP**   | Real-time gameplay (inputs, state updates)                  | Each datagram contains **one full packet** (â‰¤512 bytes). Multiple commands may be batched, but the entire datagram must fit in one UDP payload.  |

> Because the same format is used on both transports, **serialization and parsing logic can be shared** between TCP and UDP code paths.

***

## Example

An `EXAMPLE` command (ID = 10) with a 4-byte body sent with direction code `01`:

* Direction = `01`
* ID = `10` -> binary `01010`
* Body length = `4` -> binary `000000100`

Full 16-bit header (big-endian):
`01 01010 000000100` -> grouped as two bytes:

* Byte 0: `01010100` = `0x54`
* Byte 1: `00000100` = `0x04`

Header sent: `0x54 0x04`
Followed by 4 bytes of payload data.


# RFC format documentation



```
Network Working Group                                 Ulysse Mercadal
Request for Comments: XXXX                               Epitech Lyon
Category: Informational                              28 November 2025


                     Protocole R-Type v1.0.1


Status of this Memo

   This memo provides information for the Internet community. It does
   not specify an Internet standard of any kind. Distribution of this
   memo is unlimited.

Copyright Notice

   Copyright (C) 2025. All Rights Reserved.

Abstract

   This document specifies the R-Type Protocol, a lightweight,
   modular network protocol designed to enable real-time multiplayer
   communication between game clients and dedicated servers. The
   protocol uses TCP for initial handshake and UDP for gameplay data
   transmission.


Table of Contents

   1. Introduction to the R-Type Protocol . . . . . . . . . . . . . . 3
   2. Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
   3. Communication Flow  . . . . . . . . . . . . . . . . . . . . . . 3
   4. Header and Body . . . . . . . . . . . . . . . . . . . . . . . . 4
   5. Protocol Commands . . . . . . . . . . . . . . . . . . . . . . 4-6
   6. Protocol Limitations  . . . . . . . . . . . . . . . . . . . . 6-7
   7. Packet Structure  . . . . . . . . . . . . . . . . . . . . . . 7-8
   8. Command Format  . . . . . . . . . . . . . . . . . . . . . . . 7-9
   9. Usage Across Transports . . . . . . . . . . . . . . . . . . . 8-9
   10. Command Specifications . . . . . . . . . . . . . . . . . .  9-31
       10.1. Connection (0x00)  . . . . . . . . . . . . . . . . .  9-10
       10.2. Disconnection (0x01) . . . . . . . . . . . . . . . . 10-11
       10.3. Get Lobby (0x02) . . . . . . . . . . . . . . . . . . 11-13
       10.4. Join Lobby (0x03)  . . . . . . . . . . . . . . . . . 13-14
       10.5. Leave Lobby (0x04) . . . . . . . . . . . . . . . . . 14-15
       10.6. Ready (0x05) . . . . . . . . . . . . . . . . . . . . .  16
       10.7. Start Game (0x06)  . . . . . . . . . . . . . . . . . .  17
       10.8. Game Loaded (0x07) . . . . . . . . . . . . . . . . . 18-19
       10.9. Game Start (0x08)  . . . . . . . . . . . . . . . . . 19-20
       10.10. Pause (0x09)  . . . . . . . . . . . . . . . . . . . 19-20
       10.11. Win (0x0A)  . . . . . . . . . . . . . . . . . . . . 20-21
       10.12. Lose (0x0B) . . . . . . . . . . . . . . . . . . . . 21-22
       10.13. Dead (0x0C) . . . . . . . . . . . . . . . . . . . . .  22


Ulysse Mercadal             Informational                      [Page 1]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


       10.14. Input (0x0D)  . . . . . . . . . . . . . . . . . . . 22-23
       10.15. Move (0x0E) . . . . . . . . . . . . . . . . . . . . 23-24
       10.16. Set Position (0x0F) . . . . . . . . . . . . . . . . 24-25
       10.17. Get Coords (0x10) . . . . . . . . . . . . . . . . . 25-26
       10.18. Player Info (0x11)  . . . . . . . . . . . . . . . . 26-28
       10.19. Damage (0x12) . . . . . . . . . . . . . . . . . . . 28-29
       10.20. Ability (0x13)  . . . . . . . . . . . . . . . . . . 29-30
       10.21. Score (0x14)  . . . . . . . . . . . . . . . . . . . .  30
       10.22. Message (0x15)  . . . . . . . . . . . . . . . . . . 30-31









































Ulysse Mercadal             Informational                      [Page 2]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


1. Introduction to the R-Type Protocol

   The R-Type Protocol is a lightweight, modular network protocol
   designed to enable real-time multiplayer communication between a
   game client (specifically the R-Type 3D client) and a dedicated
   server.


2. Goals

   The protocol was built with the following key objectives:

   - Modularity & Reusability: It is intentionally decoupled from
     game logic, making it adaptable to virtually any real-time
     multiplayer game - not just R-Type.

   - Performance: To minimize latency, the protocol uses TCP only
     for the initial connection handshake, then switches to UDP for
     all gameplay data, ensuring fast and efficient transmission.

   - Bandwidth Efficiency: Game data is packaged into compact binary
     messages that may contain multiple commands (e.g., movement +
     shooting + state change) in a single packet, reducing overall
     network overhead.


3. Communication Flow

   1. Initial Connection (TCP)
      The client establishes a TCP connection to the server to
      perform a secure handshake: exchanging version info,
      authentication tokens, and receiving a unique session ID.

   2. Gameplay Communication (UDP)
      After the session is validated, all real-time gameplay
      updates - such as player input, entity states, and events -
      are transmitted over UDP. This provides the low-latency
      responsiveness required for fast-paced action games.

   3. Multiplexed Packets
      Each UDP packet can carry one or more commands. This batching
      mechanism optimizes bandwidth usage and reduces packet count,
      which is crucial for maintaining smooth synchronization under
      varying network conditions.

   It contains no hardcoded game logic, allowing seamless
   integration into other game engines or genres (e.g., platformers,
   shooters, real-time strategy) with minimal adaptation.


Ulysse Mercadal             Informational                      [Page 3]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


4. Header and Body

   The command are split in two main parts the header and the body.
   The header contains information about the command, the sender,
   and the body size. The body contains the additional information
   (name, positions, status...)

   This document serves as the foundation for the full R-Type
   Protocol specification. Subsequent sections will detail packet
   structures, supported command types, sequence numbering, and
   strategies for handling packet loss in UDP streams.


5. Protocol Commands

   Each message in the R-Type Protocol is identified by an 8-bit
   command ID. The same ID may be used for related actions (e.g.,
   client request and server broadcast), and the exact meaning is
   determined by the header. Below is the complete list of supported
   commands.

   Note:
   - All commands respect the 512-byte packet limit. Large payloads
     (e.g., long messages) must be split across multiple packets.
   - The same command ID is used for both requests and
     notifications/responses

    int this command array, B collumv goes for broadcast
   +------+------------------+----------+------------------------+---+
   | ID   | Name             | Protocol | Description            | B |
   +------+------------------+----------+------------------------+---+
   | 0x00 | CONNECTION       | TCP      | Initiates connection   | N |
   |      |                  |          | with the server.       |   |
   +------+------------------+----------+------------------------+---+
   | 0x01 | DISCONNECTION    | TCP      | Signals disconnection  | N |
   |      |                  |          | from the server. may   |   |
   |      |                  |          | trigger a LEAVE_LOBBY  |   |
   |      |                  |          | if player in game      |   |
   +------+------------------+----------+------------------------+---+
   | 0x02 | GET_LOBBY        | TCP      | Request or give all    | N |
   |      |                  |          | the existing lobby     |   |
   +------+------------------+----------+------------------------+---+
   | 0x03 | JOIN_LOBBY       | TCP      | Request or signal a    | Y |
   |      |                  |          | new player in the      |   |
   |      |                  |          | lobby, The server      |   |
   |      |                  |          | replies with the new   |   |
   |      |                  |          | player list.           |   |
   +------+------------------+----------+------------------------+---+


Ulysse Mercadal             Informational                      [Page 4]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   | 0x04 | LEAVE_LOBBY      | TCP      | Request to leave the   | Y |
   |      |                  |          | current lobby.         |   |
   +------+------------------+----------+------------------------+---+
   | 0x05 | READY            | TCP      | Change a player's      | Y |
   |      |                  |          | readiness state in     |   |
   |      |                  |          | the lobby.             |   |
   +------+------------------+----------+------------------------+---+
   | 0x06 | START_GAME       | TCP      | Ask or notify the      | Y |
   |      |                  |          | match is begining.     |   |
   +------+------------------+----------+------------------------+---+
   | 0x07 | GAME_LOADED      | TCP      | Sent once local assets | N |
   |      |                  |          | are loaded. Server     |   |
   |      |                  |          | waits before sending   |   |
   |      |                  |          | GAME_START.            |   |
   +------+------------------+----------+------------------------+---+
   | 0x08 | GAME_START       | TCP      | Final signal from the  | Y |
   |      |                  |          | server that the game   |   |
   |      |                  |          | loop is starting.      |   |
   +------+------------------+----------+------------------------+---+
   | 0x09 | PAUSE            | TCP      | Update game pause      | Y |
   |      |                  |          | state.                 |   |
   +------+------------------+----------+------------------------+---+
   | 0x0A | WIN              | TCP      | Notifies victory       | Y |
   +------+------------------+----------+------------------------+---+
   | 0x0B | LOSE             | TCP      | Notifies defeat        | Y |
   +------+------------------+----------+------------------------+---+
   | 0x0C | DEAD             | TCP      | Notifies that a player | Y |
   |      |                  |          | or entity has been     |   |
   |      |                  |          | destroyed.             |   |
   +------+------------------+----------+------------------------+---+
   | 0x0D | INPUT            | UDP      | Reports a player input | Y |
   |      |                  |          | action, identified by  |   |
   |      |                  |          | a key for more         |   |
   |      |                  |          | modularity.            |   |
   +------+------------------+----------+------------------------+---+
   | 0x0E | MOVE             | UDP      | Updates a player's     | Y |
   |      |                  |          | position in 3D space   |   |
   |      |                  |          | x, y, z.               |   |
   +------+------------------+----------+------------------------+---+
   | 0x0F | SET_POSITION     | UDP      | Forces an absolute     | Y |
   |      |                  |          | position update.       |   |
   +------+------------------+----------+------------------------+---+
   | 0x10 | GET_COORDS       | UDP      | Requests current       | N |
   |      |                  |          | coordinates of an      |   |
   |      |                  |          | entity.                |   |
   +------+------------------+----------+------------------------+---+




Ulysse Mercadal             Informational                      [Page 5]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   | 0x11 | PLAYER_INFO      | UDP      | Requests or give       | * |
   |      |                  |          | detailed player data   |   |
   +------+------------------+----------+------------------------+---+
   | 0x12 | DAMAGE           | UDP      | Notifies that an       | Y |
   |      |                  |          | entity has taken       |   |
   |      |                  |          | damage.                |   |
   +------+------------------+----------+------------------------+---+
   | 0x13 | ABILITY          | UDP      | notify that a entity   | Y |
   |      |                  |          | use one of his         |   |
   |      |                  |          | abilities.             |   |
   +------+------------------+----------+------------------------+---+
   | 0x14 | SCORE            | UDP      | Updates a player's     | N |
   |      |                  |          | score.                 |   |
   +------+------------------+----------+------------------------+---+
   | 0x15 | MESSAGE          | UDP      | Sends a text message   | Y |
   +------+------------------+----------+------------------------+---+

   Note: B column indicates Broadcast (Y = yes, N = no, * = depends)


6. Protocol Limitations

   Param size:

   - This ptococole can't have more than 255 versions id, because
     it's a uint8

   - A server can't host more than 255 players, because it's a uint8

   - A server can't host more than 255 lobbys, because it's a uint8

   - A lobby can't host more than 255 players, because it's a uint8

   - You can't handle more than 255 input keys id, because it's a
     uint8

   - A player name must be a string with a length between 1, and 20
     chars

   - A lobby name must be a string with a length between 1, and 20
     chars

   - A level can't have more than 65534 npcs because it's a uint16

   - A player can't take more than 65534 dammages because it's a
     uint16




Ulysse Mercadal             Informational                      [Page 6]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


7. Packet Structure

   The R-Type Protocol uses a uniform binary packet format for all
   communication, whether sent over TCP (e.g., during handshake or
   reliable control messages) or UDP (for real-time gameplay
   updates). This ensures consistency across transport layers while
   allowing the protocol to remain transport-agnostic at the message
   level.

   7.1. General Rules

   - Maximum size per packet: 512 bytes (including header and body).

   - A single packet may contain one or more concatenated commands.

   - If the total data exceeds 512 bytes, it must be split into
     multiple packets.

   - Each command is self-contained and consists of a 2-byte header
     + an optional body (0 to 510 bytes).

   - Command bodies are optional: some commands have an empty body
     (body length = 0), while others carry structured game data.

   Note: Even during the TCP handshake phase, messages follow this
   exact format. The transport layer (TCP vs. UDP) affects delivery
   guarantees and latency, not the message encoding.


8. Command Format

   Each command starts with a 2-byte (16-bit) header, followed by a
   body whose length is declared in the header.

   8.1. Header Layout (2 bytes)

   +----------+---------------+------------------------------------+
   | Bits     | Field         | Description                        |
   +----------+---------------+------------------------------------+
   | 15-14    | Direction     | 2-bit direction code (e.g., 00 =  |
   |          |               | request, 01 = response - semantics |
   |          |               | defined by context)                |
   +----------+---------------+------------------------------------+
   | 13-9     | Command ID    | 5-bit unsigned integer (0-31)      |
   |          |               | identifying the command type       |
   +----------+---------------+------------------------------------+
   | 8-0      | Body Length   | 9-bit unsigned integer (0-511)     |
   |          |               | indicating the size of the body    |


Ulysse Mercadal             Informational                      [Page 7]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   |          |               | in bytes                           |
   +----------+---------------+------------------------------------+

   The body length does not include the 2-byte header... well
   because a header is not a body :)

   8.2. Visual bit layout:

   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
   | D| D| I| I| I| I| I| L| L| L| L| L| L| L| L| L|
   +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

   Where:
   - D = Direction (2 bits -> 4 possible values)
   - I = Command ID (5 bits -> max 31)
   - L = Body length (9 bits -> max 511)


9. Usage Across Transports

   +----------+-------------------------------+----------------------+
   |Transport | Typical Use Case              | Packet Handling      |
   +----------+-------------------------------+----------------------+
   | TCP      | Handshake, authentication,    | Packets are sent as  |
   |          | session setup, reliable       | a stream; the        |
   |          | commands                      | receiver must frame  |
   |          |                               | messages using the   |
   |          |                               | known 2-byte header  |
   |          |                               | + declared body      |
   |          |                               | length to delimit    |
   |          |                               | commands.            |
   +----------+-------------------------------+----------------------+
   | UDP      | Real-time gameplay (inputs,   | Each datagram        |
   |          | state updates)                | contains one full    |
   |          |                               | packet (<=512 bytes).|
   |          |                               | Multiple commands    |
   |          |                               | may be batched, but  |
   |          |                               | the entire datagram  |
   |          |                               | must fit in one UDP  |
   |          |                               | payload.             |
   +----------+-------------------------------+----------------------+

   Because the same format is used on both transports,
   serialization and parsing logic can be shared between TCP and UDP
   code paths.



Ulysse Mercadal             Informational                      [Page 8]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   9.1. Example

   An EXAMPLE command (ID = 10) with a 4-byte body sent with
   direction code 01:

   - Direction = 01
   - ID = 10 -> binary 01010
   - Body length = 4 -> binary 000000100

   Full 16-bit header (big-endian):
   01 01010 000000100 -> grouped as two bytes:

   - Byte 0: 01010100 = 0x54
   - Byte 1: 00000100 = 0x04

   Header sent: 0x54 0x04

   Followed by 4 bytes of payload data.


10. Command Specifications

10.1. Connection (ID 0)

   This command is used to initiate and accept a new client
   connection to the server. It is the first message sent by a
   client after opening a TCP socket. The server responds to
   indicate whether the connection is accepted (e.g., due to version
   compatibility or server capacity).

   Warning! This command must be sent over TCP. It is part of the
   initial handshake phase.

   10.1.1. Client -> Server

   Context:
   The client attempts to connect to the server and declares the
   protocol version it supports.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00000     | 000000001        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x40 0x01
   (Binary: 01 00000 000000001 - 01000000 00000001)


Ulysse Mercadal             Informational                      [Page 9]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Body:
   +--------------+--------+---------------------------+
   | Size (bytes) | Type   | Content                   |
   +--------------+--------+---------------------------+
   | 1            | uint8  | Protocol version number   |
   +--------------+--------+---------------------------+

   10.1.2. Server -> Client

   Context:
   The server responds to the connection request, indicating
   acceptance or rejection.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00000     | 000000001        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x00 0x01
   (Binary: 00 00000 000000001 - 00000000 00000001)

   Body:
   +--------------+--------+----------------------------------+
   | Size (bytes) | Type   | Content                          |
   +--------------+--------+----------------------------------+
   | 1/8          | bool   | Connection status: 1 = accepted, |
   |              |        | 0 = rejected                     |
   +--------------+--------+----------------------------------+


10.2. Disconnection (ID 1)

   This command is used to terminate a session - either initiated by
   the client (voluntary leave) or by the server (kick).

   Warning! This command uses TCP exclusively.

   If a player is in an active match, you may want to first send a
   game-level leave notification (e.g., LEAVE_LOBBY) before issuing
   this command.

   10.2.1. Client -> Server

   Context:
   The client requests a graceful disconnection from the server.



Ulysse Mercadal             Informational                      [Page 10]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00001     | 000000000        |
   +---------------+-----------+------------------+

   Raw header bytes (big-endian): 0x42 0x00
   (Binary: 01 00001 000000000 - 01000010 00000000)

   Body:
   None.

   10.2.2. Server -> Client

   Context:
   The server forcibly disconnects (kicks) the client, optionally
   providing a reason.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00001     | N                |
   +---------------+-----------+------------------+

   Where N is the length of the reason string (<=510 bytes to
   respect the 512-byte packet limit).

   Example (reason = ratio!!):
   Body length = 8 - 000001000
   Header bytes: 0x02 0x08
   (Binary: 00 00001 000001000 - 00000010 00001000)

   Body:
   +--------------+----------+-----------------------+
   | Size (bytes) | Type     | Content               |
   +--------------+----------+-----------------------+
   | N (0-510)    | string   | Reason message        |
   +--------------+----------+-----------------------+

   If the body length is 0, no reason is provided (silent kick).


10.3. Get Lobby (ID 2)

   This command is used to request the list of active lobbies from



Ulysse Mercadal             Informational                     [Page 11]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   the server, or for the server to respond with that list. Each
   lobby entry includes its name and current player count.

   This command must be sent over TCP.

   10.3.1. Client -> Server

   Context:
   The client requests the full list of available lobbies (e.g., for
   a matchmaking menu).

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00010     | 000000000        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x44 0x00
   (Binary: 01 00010 000000000 - 01000100 00000000)

   Body:
   None.

   10.3.2. Server -> Client

   Context:
   The server sends the current list of lobbies in response to a
   GET_LOBBY request.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00010     | N*(M + 3)        |
   +---------------+-----------+------------------+

   Where N is the total size of the lobby list.
   Where M is the total size of the lobby name.

   Body:
   The body is a concatenated list of lobby entries. Each entry has
   the following layout:

   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Lobby ID                    |
   | 1            | uint8    | Player count                |

Ulysse Mercadal             Informational                     [Page 12]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   | M (1-20)     | string   | Lobby name                  |
   +--------------+----------+-----------------------------+

   - If no lobbies exist, the body is empty (N = 0).


10.4. Join Lobby (ID 3)

   This command allows a client to either join an existing game
   lobby (by ID) or create a new lobby (by name). The server
   responds with success or failure.

   Warning! This command must be sent over TCP.

   10.4.1. Client -> Server

   Context:
   The client requests to join or create a lobby.

   Header (Join):
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00011     | 000000001        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x46 0x01
   (Binary: 01 00011 000000001 - 01000110 00000001)

   Header (Create):
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00011     | N                |
   +---------------+-----------+------------------+

   Where N = length of Lobby name (1-20 bytes).

   Example (name = "R-Type Arena"):
   Body length = 13 - 000001101
   Header bytes: 0x46 0x0D
   (Binary: 01 00011 000001101 - 01000110 00001101)

      Body (Join):
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Lobby ID                    |


Ulysse Mercadal             Informational                     [Page 13]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   | M            | string   | Player Name                 |
   +--------------+----------+-----------------------------+

   Where M = length of Player name (1-20 bytes).

   Body (Create):
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | N (1-20)     | string   | Lobby name                  |
   | M (1-20)     | string   | Player Name                 |
   +--------------+----------+-----------------------------+

   Where N = length of Lobby name (1-20 bytes).
   Where M = length of Player name (1-20 bytes).

   10.4.2. Server -> Client

   Context:
   The server responds to the join/create request.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00011     | N                |
   +---------------+-----------+------------------+

   Where N = length of response body (0-510).

   Example (success, no message):
   Body length = 1 - 000000001
   Header bytes: 0x06 0x01
   (Binary: 00 00011 000000001 - 00000110 00000001)

   Body:
   +--------------+----------+----------------------------------+
   | Size (bytes) | Type     | Content                          |
   +--------------+----------+----------------------------------+
   | 1/8          | bool     | Connection status: 1 = accepted, |
   |              |          | 0 = rejected                     |
   | N > 0        | string   | Additional message (e.g., "Lobby |
   |              |          | full", "wrong name")             |
   +--------------+----------+----------------------------------+

10.5. Leave Lobby (ID 4)

   This command allows a client to leave a lobby. The server


Ulysse Mercadal             Informational                     [Page 14]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   responds with success or failure.

   Warning! This command must be sent over TCP.

   10.5.1. Client -> Server

   Context:
   The client requests to leave a lobby.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00100     | 000000000        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x48 0x00
   (Binary: 01 00100 000000000 - 01001000 00000000)

   Body:
   None.

   10.5.2. Server -> Client

   Context:
   The server responds to the leave request.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00100     | 000000001        |
   +---------------+-----------+------------------+

   Example:
   Body length = 1 - 000000001
   Header bytes: 0x08 0x01
   (Binary: 00 00100 000000001 - 00001000 00000001)


   Body:
   +--------------+----------+----------------------------------+
   | Size (bytes) | Type     | Content                          |
   +--------------+----------+----------------------------------+
   | 1/8          | bool     | Leaving status: 1 = accepted,    |
   |              |          | 0 = error                        |
   +--------------+----------+----------------------------------+



Ulysse Mercadal             Informational                     [Page 15]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


10.6. Ready (ID 5)

   This command allows a client to set his status as ready or not
   ready in a lobby. The server responds with success or failure.

   Warning! This command must be sent over TCP.

   10.6.1. Client -> Server

   Context:
   The client requests to change his ready status.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00101     | 000000000        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x4A 0x00
   (Binary: 01 00101 000000000 - 01001010 00000000)

   Body:
   None.

   10.6.2. Server -> Client

   Context:
   The server responds to the ready request.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00101     | 000000001        |
   +---------------+-----------+------------------+

   Example:
   Body length = 1 - 000000001
   Header bytes: 0x0A 0x01
   (Binary: 00 00101 000000001 - 00001010 00000001)

   Body:
   +--------------+----------+----------------------------------+
   | Size (bytes) | Type     | Content                          |
   +--------------+----------+----------------------------------+
   | 1/8          | bool     | Ready status: 1 = accepted,      |
   |              |          | 0 = error                        |
   +--------------+----------+----------------------------------+

Ulysse Mercadal             Informational                     [Page 16]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


10.7. Start Game (ID 6)

   This command allows a client or the server to start the game
   initialization procedure.

   Warning! This command must be sent over TCP.

   10.7.1. Client -> Server

   Context:
   The client (e.g., game leader) requests to start the game
   loading procedure.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00110     | 000000000        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x4C 0x00
   (Binary: 01 00110 000000000 - 01001100 00000000)

   Body:
   None.

   10.7.2. Server -> Client

   Context:
   The server responds to the start request.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00110     | N                |
   +---------------+-----------+------------------+

   Where N = map configuration file content (0-510).

   Note: Since the information on the game map can be very
   extensive, the START_GAME command is particularly likely to be
   split into several commands.

   Example (a lot of map information):
   Body length = 510 - 111111110
   Header bytes: 0x0C 0xFE
   (Binary: 00 00110 111111110 - 00001100 11111110)


Ulysse Mercadal             Informational                     [Page 17]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | N            | string   | Map configuration file      |
   |              |          | content                     |
   +--------------+----------+-----------------------------+


10.8. Game Loaded (ID 7)

   This command notifies a client or the server that map loading is
   done.

   Warning! This command must be sent over TCP.

   10.8.1. Client -> Server

   Context:
   The client notifies the server that his local assets loading is
   done.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 00111     | 000000000        |
   +---------------+-----------+------------------+


Ulysse Mercadal             Informational                     [Page 18]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Raw header bytes: 0x4E 0x00
   (Binary: 01 00111 000000000 - 01001110 00000000)

   Body:
   None.

   10.8.2. Server -> Client

   Context:
   The server notifies the client that the game is starting. This
   command is sent after the server has received "loading done"
   confirmations from all ready clients.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 00111     | 000000000        |
   +---------------+-----------+------------------+

   Example:
   Body length = 0 - 000000000
   Header bytes: 0x0E 0x00
   (Binary: 00 00111 000000000 - 00001110 00000000)

   Body:
   None.


10.9. Game Start (ID 8)

   This command is sent by the server to officially start the game
   loop after all players have finished loading.

   Warning! This command must be sent over TCP.
   Note: This command can only be sent by the server.

   10.9.1. Server -> Client

   Context:
   The server notifies all connected clients that the match is now
   starting. This message marks the transition from lobby/loading
   phase to active gameplay.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01000     | 000000000        |
   +---------------+-----------+------------------+

   Example:
   Body length = 0 - 000000000
   Raw header bytes: 0x10 0x00
   (Binary: 00 01000 000000000 - 00010000 00000000)

   Body:
   None.


10.10. Pause (ID 9)

   This command is used to update the game pause state.

   Warning! This command must be sent over TCP.

   10.10.1. Client -> Server



Ulysse Mercadal             Informational                     [Page 19]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Context:
   The client requests to pause or unpause the game.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 01001     | 000000001        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x52 0x01
   (Binary: 01 01001 000000001 - 01010010 00000001)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1/8          | bool     | Pause state: 1 = paused,    |
   |              |          | 0 = unpaused                |
   +--------------+----------+-----------------------------+

   10.10.2. Server -> Client

   Context:
   The server broadcasts the new pause state to all clients.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01001     | 000000001        |
   +---------------+-----------+------------------+

   Raw header bytes: 0x12 0x01
   (Binary: 00 01001 000000001 - 00010010 00000001)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1/8          | bool     | Pause state: 1 = paused,    |
   |              |          | 0 = unpaused                |
   +--------------+----------+-----------------------------+


10.11. Win (ID 10)

   This command notifies that a player or team has won the game.


Ulysse Mercadal             Informational                     [Page 20]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025

Warning! This command must be sent over TCP.
   Note: This command can only be sent by the server.

   10.11.1. Server -> Client

   Context:
   The server notifies the client of a victory condition being met.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01010     | N                |
   +---------------+-----------+------------------+

   Where N = Winner name (1-20 bytes).

   Example (name = "Michel"):
   Body length = 7 - 000000111
   Raw header bytes: 0x14 0x07
   (Binary: 00 01010 000000111 - 00010100 00000111)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | N            | string   | Win player name             |
   +--------------+----------+-----------------------------+


10.12. Lose (ID 11)

   This command is sent by the server to notify a client that they
   have lost the game. It marks the end of the match for the player.

   Warning! This command must be sent over TCP.
   Note: This command can only be sent by the server.

   10.12.1. Server -> Client

   Context:
   The server notifies the client that a defeat condition has been
   met.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01011     | N                |
   +---------------+-----------+------------------+

Ulysse Mercadal             Informational                     [Page 21]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Where N = Loser name (1-20 bytes), or 0 if no one lost.

   Example (name = "Michel"):
   Body length = 7 - 000000111
   Raw header bytes: 0x16 0x07
   (Binary: 00 01011 000000111 - 00010110 00000111)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | N            | string   | Loser player name           |
   +--------------+----------+-----------------------------+


10.13. Dead (ID 12)

   This command is sent by the server to notify clients that a
   player has died.

   Warning! This command must be sent over TCP.
   Note: This command can only be sent by the server.

   10.13.1. Server -> Client

   Context:
   The server notifies clients that a player entity has been
   destroyed (e.g., hit by enemy, out of bounds).

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01100     | N                |
   +---------------+-----------+------------------+

   Where N = Dead player name (1-20 bytes).

   Example (name = "Michel"):
   Body length = 7 - 000000111
   Raw header bytes: 0x18 0x07
   (Binary: 00 01100 000000111 - 00011000 00000111)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | N            | string   | Dead player name            |
   +--------------+----------+-----------------------------+

Ulysse Mercadal             Informational                     [Page 22]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


10.14. Input (ID 13)

   This command is used to send a player input (press/release) and
   receive immediate feedback from the server on whether the action
   was applied, denied, or requires follow-up.

   Warning! This command must be sent over UDP.

   10.14.1. Client -> Server

   Context:
   The client sends a real-time input event.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 01101     | 000000010        |
   +---------------+-----------+------------------+

   Example:
   Body length = 2 - 000000010
   Raw header bytes: 0x5A 0x02
   (Binary: 01 01101 000000010 - 01011010 00000010)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Key ID                      |
   | 1/8          | bool     | Action (1=press, 0=release) |
   +--------------+----------+-----------------------------+

   10.14.2. Server -> Client

   Context:
   The server responds with execution status:
   - FAILED: unauthorized input
   - SUCCESS: action processed
   - LATER: action success, but handled in a future command (e.g.,
     will send MOVE later)

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01101     | 000000010        |
   +---------------+-----------+------------------+


Ulysse Mercadal             Informational                     [Page 23]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Example (key_id = 5, press, status = LATER):
   Body length = 2 - 000000010
   Raw header bytes: 0x1A 0x02
   (Binary: 00 01101 000000010 - 00011010 00000010)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Key ID (echoed)             |
   | 1/8          | bool     | Action (echoed)             |
   | 2/8          | enum     | Status (00=FAILED,          |
   |              |          | 01=SUCCESS, 10=LATER)       |
   +--------------+----------+-----------------------------+


10.15. Move (ID 14)

   This command is sent by the server to notify a client of a
   player's updated position in 3D space. Positions are encoded as
   16-bit signed integers scaled by 0.01 for bandwidth efficiency.

   Warning! This command must be sent over UDP.
   Note: This command can only be sent by the server.

   10.15.1. Server -> Client

   Context:
   The server broadcasts the new coordinates of a player entity
   after simulating movement. World positions are converted to
   scaled integers before transmission.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01110     | 000000111        |
   +---------------+-----------+------------------+

   Example:
   Body length = 7 - 000000111
   Raw header bytes: 0x1C 0x07
   (Binary: 00 01110 000000111 - 00011100 00000111)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Player ID                   |


Ulysse Mercadal             Informational                     [Page 24]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   | 2            | int16    | X position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Y position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Z position (world = value * |
   |              |          | 0.01)                       |
   +--------------+----------+-----------------------------+


10.16. Set Position (ID 15)

   This command is sent by the server to force an absolute position
   update for a player. World positions are converted to scaled
   integers before transmission.

   Warning! This command must be sent over UDP.
   Note: This command can only be sent by the server.

   10.16.1. Server -> Client

   Context:
   The server sets a player's position to an exact location in the
   world, bypassing everything.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 01111     | 000000111        |
   +---------------+-----------+------------------+

   Example:
   Body length = 7 - 000000111
   Raw header bytes: 0x1E 0x07
   (Binary: 00 01111 000000111 - 00011110 00000111)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Player ID                   |
   | 2            | int16    | X position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Y position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Z position (world = value * |
   |              |          | 0.01)                       |
   +--------------+----------+-----------------------------+

Ulysse Mercadal             Informational                     [Page 25]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


10.17. Get Coords (ID 16)

   This command is sent by the client to request the current
   position of an entity. The server responds with its positions.
   World positions are converted to scaled integers before
   transmission.

   Warning! This command must be sent over UDP.

   10.17.1. Client -> Server

   Context:
   The client requests up-to-date coordinates of an entity.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 10000     | 000000001        |
   +---------------+-----------+------------------+

   Example:
   Body length = 1 - 000000001
   Raw header bytes: 0x60 0x01
   (Binary: 01 10000 000000001 - 01100000 00000001)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Entity ID                   |
   +--------------+----------+-----------------------------+

   10.17.2. Server -> Client

   Context:
   The server sends the coordinates of the asked entity.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 10000     | 000000111        |
   +---------------+-----------+------------------+

   Example:
   Body length = 7 - 000000111
   Raw header bytes: 0x20 0x07
   (Binary: 00 10000 000000111 - 00100000 00000111)

Ulysse Mercadal             Informational                     [Page 26]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Entity ID (echoed)          |
   | 2            | int16    | X position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Y position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Z position (world = value * |
   |              |          | 0.01)                       |
   +--------------+----------+-----------------------------+


10.18. Player Info (ID 17)

   This command is used by the client to request information about
   another player. The server responds with the player's name,
   position, and score.

   Warning! This command must be sent over UDP.

   10.18.1. Client -> Server

   Context:
   The client requests detailed information about another player.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 10001     | 000000001        |
   +---------------+-----------+------------------+

   Example:
   Body length = 1 - 000000001
   Raw header bytes: 0x62 0x01
   (Binary: 01 10001 000000001 - 01100010 00000001)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Player ID                   |
   +--------------+----------+-----------------------------+

   10.18.2. Server -> Client



Ulysse Mercadal             Informational                     [Page 27]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Context:
   The server sends detailed information about the requested player.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 10001     | 11+N             |
   +---------------+-----------+------------------+

   Where N = player name length (1-20 bytes).

   Example (name = "Michel", N=6):
   Body length = 11 + 6 = 17 - 000010001
   Raw header bytes: 0x22 0x11
   (Binary: 00 10001 000010001 - 00100010 00010001)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 1            | uint8    | Player ID                   |
   | N            | string   | Player name                 |
   | 2            | int16    | X position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Y position (world = value * |
   |              |          | 0.01)                       |
   | 2            | int16    | Z position (world = value * |
   |              |          | 0.01)                       |
   | 4            | uint32   | Score                       |
   +--------------+----------+-----------------------------+


10.19. Damage (ID 18)

   This command is sent by the server to notify clients that an
   entity has taken damage.

   Warning! This command must be sent over UDP.
   Note: This command can only be sent by the server.

   10.19.1. Server -> Client

   Context:
   The server broadcasts a damage event (e.g., player hit by enemy
   fire).

   Header:


Ulysse Mercadal             Informational                     [Page 28]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025

   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 10010     | 000000111        |
   +---------------+-----------+------------------+

   Example:
   Body length = 7 - 000000111
   Raw header bytes: 0x24 0x07
   (Binary: 00 10010 000000111 - 00100100 00000111)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 2            | uint16   | Victim ID                   |
   | 1/8          | bool     | Victim type (1=player,      |
   |              |          | 0=NPC)                      |
   | 2            | uint16   | Source ID                   |
   | 1/8          | bool     | Source type (1=player,      |
   |              |          | 0=NPC)                      |
   | 2            | uint16   | Damage amount               |
   +--------------+----------+-----------------------------+


10.20. Ability (ID 19)

   This command is sent by the server to notify clients that an
   entity has used an ability.

   Warning! This command must be sent over UDP.
   Note: This command can only be sent by the server.

   10.20.1. Server -> Client

   Context:
   The server broadcasts an ability usage event.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 10011     | 000000101        |
   +---------------+-----------+------------------+

   Example:
   Body length = 5 - 000000101
   Raw header bytes: 0x26 0x05
   (Binary: 00 10011 000000101 - 00100110 00000101)


Ulysse Mercadal             Informational                     [Page 29]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 2            | uint16   | Entity ID                   |
   | 1/8          | bool     | Entity type (1=player,      |
   |              |          | 0=NPC)                      |
   | 2            | uint16   | Ability ID                  |
   +--------------+----------+-----------------------------+


10.21. Score (ID 20)

   This command is sent by the server to notify clients of a
   player's updated score.

   Warning! This command must be sent over UDP.
   Note: This command can only be sent by the server.

   10.21.1. Server -> Client

   Context:
   The server broadcasts a score update.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 10100     | 000000110        |
   +---------------+-----------+------------------+

   Example:
   Body length = 6 - 000000110
   Raw header bytes: 0x28 0x06
   (Binary: 00 10100 000000110 - 00101000 00000110)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 2            | uint16   | Entity ID                   |
   | 4            | uint32   | Score                       |
   +--------------+----------+-----------------------------+







Ulysse Mercadal             Informational                     [Page 30]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


10.22. Message (ID 21)

   This command is used to send and broadcast text messages. The
   client sends a message to the server, and the server rebroadcasts
   it to all clients.

   Warning! This command must be sent over UDP.

   10.22.1. Client -> Server

   Context:
   The client sends a chat message or request to the server.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 01            | 10101     | N                |
   +---------------+-----------+------------------+

   Where N = message length (1-127 bytes).

   Example (message = "Hello", N=5):
   Body length = 5 - 000000101
   Raw header bytes: 0x6A 0x05
   (Binary: 01 10101 000000101 - 01101010 00000101)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | N            | string   | Message text                |
   +--------------+----------+-----------------------------+

   10.22.2. Server -> Client

   Context:
   The server broadcasts a message received from a client or
   generated internally.

   Header:
   +---------------+-----------+------------------+
   | Direction     | Code      | Body Length      |
   +---------------+-----------+------------------+
   | 00            | 10101     | 3+N              |
   +---------------+-----------+------------------+

   Where N = message length (1-127 bytes).


Ulysse Mercadal             Informational                     [Page 31]

RFC XXXX                Protocole R-Type v1.0.1        28 November 2025


   Example (player 42 says "EZ u noob", N=9):
   Body length = 3 + 9 = 12 - 000001100
   Raw header bytes: 0x2A 0x0C
   (Binary: 00 10101 000001100 - 00101010 00001100)

   Body:
   +--------------+----------+-----------------------------+
   | Size (bytes) | Type     | Content                     |
   +--------------+----------+-----------------------------+
   | 2            | uint16   | Entity ID (0=system)        |
   | 1/8          | bool     | Entity type (1=player,      |
   |              |          | 0=NPC/system)               |
   | N            | string   | Message text                |
   +--------------+----------+-----------------------------+




































Ulysse Mercadal             Informational                     [Page 32]
```


# 0x00 - Connection



# Connection (ID 0)

This command is used to **initiate and accept** a new client connection to the server. It is the **first message** sent by a client after opening a TCP socket. The server responds to indicate whether the connection is accepted (e.g., due to version compatibility or server capacity).

> warning! **This command must be sent over TCP.** It is part of the initial handshake phase.

***

## Client -> Server

### Context

The client attempts to connect to the server and declares the protocol version it supports.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00000` | `000000001` |

**Raw header bytes:** `0x40 0x01`

*(Binary: `01 00000 000000001` - `01000000 00000001`)*

### Body

| Size (bytes) |   Type  | Content                 |
| :----------: | :-----: | ----------------------- |
|       1      | `uint8` | Protocol version number |

***

## Server -> Client

### Context

The server responds to the connection request, indicating acceptance or rejection.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `00000` | `000000001` |

**Raw header bytes:** `0x00 0x01`

*(Binary: `00 00000 000000001` - `00000000 00000001`)*

### Body

| Size (bytes) |  Type  | Content                                           |
| :----------: | :----: | ------------------------------------------------- |
|      1/8     | `bool` | Connection status: `1` = accepted, `0` = rejected |


# 0x01 - Disconnection



# Disconnection (ID 1)

This command is used to **terminate a session**â€”either initiated by the client (voluntary leave) or by the server (kick).

> warning! **This command uses TCP exclusively.**

> If a player is in an active match, you may want to first send a game-level leave notification (e.g., `LEAVE_LOBBY`) before issuing this command.

***

## Client -> Server

### Context

The client requests a graceful disconnection from the server.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00001` | `000000000` |

**Raw header bytes (big-endian):** `0x42 0x00`

*(Binary: `01 00001 000000000` - `01000010 00000000`)*

### Body

None.

***

## Server -> Client

### Context

The server forcibly disconnects (kicks) the client, optionally providing a reason.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `00001` |     *N*     |

> Where *N* is the length of the reason string (â‰¤ 510 bytes to respect the 512-byte packet limit).

### Example (reason = ratio!!):

Body length = `8` - `000001000`

Header bytes: `0x02 0x08`

*(Binary: `00 00001 000001000` - `00000010 00001000`)*

### Body

| Size (bytes) |   Type   | Content        |
| :----------: | :------: | -------------- |
|  *N* (0â€“510) | `string` | Reason message |

> If the body length is `0`, no reason is provided (silent kick).


# 0x02 - Get Lobby



# Get Lobby (ID 2)

This command is used to **request the list of active lobbies** from the server, or for the server to **respond with that list**. Each lobby entry includes its name and current player count.

> **This command must be sent over TCP.**

***

## Client -> Server

### Context

The client requests the full list of available lobbies (e.g., for a matchmaking menu).

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00010` | `000000000` |

**Raw header bytes:** `0x44 0x00`

*(Binary: `01 00010 000000000` - `01000100 00000000`)*

### Body

None.

***

## Server -> Client

### Context

The server sends the current list of lobbies in response to a `GET_LOBBY` request.

### Header

| Direction |   Code  |  Body Length |
| :-------: | :-----: | :----------: |
|    `00`   | `00010` | *N\*(M + 3)* |

> Where *N* is the total size of the lobby list.

> Where *M* is the total size of the lobby name.

### Body

The body is a **concatenated list of lobby entries**. Each entry has the following layout:

| Size (bytes) |   Type   | Content       |
| :----------: | :------: | ------------- |
|       3      |  `uint8` | player number |
|      *M*     | `string` | Lobby name    |

> * If no lobbies exist, the body is **empty** (*N* = 0).


# 0x03 - Join Lobby



# Join Lobby (ID 3)

This command allows a client to either **join an existing game lobby** (by ID) or **create a new lobby** (by name). The server responds with success or failure.

> **This command must be sent over TCP.**

***

## Client -> Server

### Context

The client requests to join or create a lobby.

### Header

Join:

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00011` | `000000001` |

**Raw header bytes:** `0x46 0x01`

*(Binary: `01 00011 000000001` - `01000110 00000001`)*

Create:

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00011` |     *N*     |

> Where *M* = length of Lobby name (1-20 bytes).

### Example (name = "R-Type Arena"):

Body length = `13` - `000001101`

Header bytes: `0x46 0x0D`

*(Binary: `01 00011 000001101` - `01000110 00001101`)*

***

### Body

Join:

| Size (bytes) |   Type   | Content     |
| :----------: | :------: | ----------- |
|       1      |  `uint8` | Lobby ID    |
|      *M*     | `string` | Player Name |

> Where *M* = length of Player name (1-20 bytes).

Create:

| Size (bytes) |   Type   | Content     |
| :----------: | :------: | ----------- |
|  *N* (3-510) | `string` | Lobby name  |
|      *M*     | `string` | Player Name |

> Where *N* = length of Player name (1-20 bytes).

> Where *M* = length of Lobby name (1-20 bytes).

***

## Server -> Client

### Context

The server responds to the join/create request.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `00011` |     *N*     |

Where *N* = length of response body (0-510).

### Example (success, no message):

Body length = `1` - `000000001`

Header bytes: `0x06 0x01`

*(Binary: `00 00011 000000000` - `00000110 00000001`)*

### Body

| Size (bytes) |   Type   | Content                                                 |
| :----------: | :------: | ------------------------------------------------------- |
|      1/8     |  `bool`  | Connection status: `1` = accepted, `0` = rejected       |
|    *N* > 0   | `string` | **Additional message** (e.g., "Lobby full, wrong name") |


# 0x04 - Leave lobby



# Leave Lobby (ID 4)

This command allows a client to **leave** a lobby. The server responds with success or failure.

> **This command must be sent over TCP.**

***

## Client -> Server

### Context

The client requests to leave a lobby.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00100` | `000000000` |

**Raw header bytes:** `0x44 0x00`

*(Binary: `01 00100 000000000` - `01001000 00000000`)*

### Body

none

***

## Server -> Client

### Context

The server responds to the leave request.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `00100` | `000000001` |

### Example:

Body length = `1` - `000000001`

Header bytes: `0x04 0x01`

*(Binary: `00 00100 000000001` - `00001000 00000001`)*

### Body

| Size (bytes) |  Type  | Content                                     |
| :----------: | :----: | ------------------------------------------- |
|      1/8     | `bool` | leaving status: `1` = accepted, `0` = error |


# 0x05 - Ready



# Ready (ID 5)

This command allows a client to set his status as **ready** or **not ready**a lobby. The server responds with success or failure.

> **This command must be sent over TCP.**

***

## Client -> Server

### Context

The client requests to change his ready status.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00101` | `000000000` |

**Raw header bytes:** `0x4A 0x00`

*(Binary: `01 00101 000000000` - `01001010 00000000`)*

### Body

none

***

## Server -> Client

### Context

The server responds to the leave request.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `00101` | `000000001` |

### Example:

Body length = `1` - `000000001`

Header bytes: `0x0A 0x01`

*(Binary: `00 00101 000000001` - `00001010 00000001`)*

### Body

| Size (bytes) |  Type  | Content                                     |
| :----------: | :----: | ------------------------------------------- |
|      1/8     | `bool` | leaving status: `1` = accepted, `0` = error |


# 0x06 - Start game



# Start game (ID 6)

This command allows a client or the server to start the game initialization procedure

> **This command must be sent over TCP.**

***

## Client -> Server

### Context

The client (e.g, game leader) requests to start the game loading procedure.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00110` | `000000000` |

**Raw header bytes:** `0x4C 0x00`

*(Binary: `01 00110 000000000` - `01001010 00000000`)*

### Body

none

***

## Server -> Client

### Context

The server responds to the start request.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `00110` |     *N*     |

> Where *N* = map configuration file content (0-510).

> Since the information on the game map can be very extensive, the `START GAME` command is particularly likely to be split into several commands.

### Example (a lot of map information):

Body length = `510` - `111111110`

Header bytes: `0x0D 0xFE`

*(Binary: `00 00110 111111110` - `00001101 11111110`)*

### Body

| Size (bytes) |   Type   | Content                        |
| :----------: | :------: | ------------------------------ |
|      *N*     | `string` | map configuration file content |


# 0x07 - Game loaded



# Game loaded (ID 7)

This command notify a client or the server that his map loading is done

> **This command must be sent over TCP.**

***

## Client -> Server

### Context

The client notify the server that his local assets loading is done.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `00111` | `000000000` |

**Raw header bytes:** `0x4E 0x00`

*(Binary: `01 00111 000000000` - `01001010 00000000`)*

### Body

none

***

## Server -> Client

### Context

The server notifies the client that the game is starting. This command is sent after the server has received "loading done" confirmations from all ready clients.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `00111` | `000000000` |

### Example:

Body length = `0` - `000000000`

Header bytes: `0x0E 0x00`

*(Binary: `00 00111 000000000` - `00001110 00000000`)*

### Body

none


# 0x08 - Game start



# Game Start (ID 8)

This command is sent by the server to officially start the game loop after all players have finished loading.

> **This command must be sent over TCP.**

> This command can only be sent by the server !

***

## Server -> Client

### Context

The server notifies all connected clients that the match is now starting. This message marks the transition from lobby/loading phase to active gameplay.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01000` | `000000000` |

### Example:

Body length = `0` - `000000000`

**Raw header bytes:** `0x10 0x00`

*(Binary: `00 01000 000000000` - `00010000 00000000`)*

### Body

None.


# 0n09 - Game pause



# Pause (ID 9)

This command is used to pause or resume the game state. It can be sent by the server or by a client.

> **This command must be sent over TCP.**

***

## Client -> Server

### Context

The client requests to toogle the pause / resume status of the current game session.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `01001` | `000000000` |

**Raw header bytes:** `0x52 0x00`

*(Binary: `01 01001 000000001` - `01010010 00000000`)*

### Body

none

***

## Server -> Client

### Context

The server enforces a pause / resumes toogle for all players.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01001` | `000000000` |

### Example:

Body length = `0` - `000000000`

**Raw header bytes:** `0x12 0x00`

*(Binary: `00 01001 000000001` - `00010010 00000000`)*

### Body

none


# 0x0A - Win



# Win (ID 10)

This command is sent by the server to notify clients that someone has won the game. It marks the end of the match.

> **This command must be sent over TCP.**

> This command can only be sent by the server!

***

## Server -> Client

### Context

The server notifies the client of a victory condition being met

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01010` |     *N*     |

> Where *N* = Winner name (1 - 20).

### Example (name = Michel):

Body length = `7` - `000000111`

**Raw header bytes:** `0x14 0x07`

*(Binary: `00 01010 000000111` - `00010100 00000111`)*

### Body

| Size (bytes) |   Type   | Content         |
| :----------: | :------: | :-------------- |
|      *N*     | `string` | Win player name |


# 0x0B - Lose



# Lose (ID 11)

This command is sent by the server to notify a client that they have lost the game. It marks the end of the match for the player.

> **This command must be sent over TCP.**

> **This command can only be sent by the server!**

***

## Server -> Client

### Context

The server notifies the client that a defeat condition has been met

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01011` |     *N*     |

> Where *N* = Loser name (1â€“20 bytes), or 0 if no one lost.

### Example (name = Michel):

Body length = `7` - `000000111`

**Raw header bytes:** `0x16 0x07`

*(Binary: `00 01011 000000111` - `00010110 00000111`)*

### Body

| Size (bytes) |   Type   | Content           |
| :----------: | :------: | :---------------- |
|      *N*     | `string` | Loser player name |


# 0x0C - Dead



# Dead (ID 12)

This command is sent by the server to notify clients that a player has died.

> **This command must be sent over TCP.**

> **This command can only be sent by the server!**

***

## Server -> Client

### Context

The server notifies clients that a player entity has been destroyed (e.g., hit by enemy, out of bounds).

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01100` |     *N*     |

> Where *N* = Dead player name (1â€“20 bytes).

### Example (name = "Michel"):

Body length = `7` - `000000111`

**Raw header bytes:** `0x18 0x07`

*(Binary: `00 01100 000000111` - `00011000 00000111`)*

### body

| Size (bytes) |   Type   | Content          |
| :----------: | :------: | :--------------- |
|      *N*     | `string` | Dead player name |


# 0x0D - Input



# Input (ID 13)

This command is used to send a player input (press/release) and receive immediate feedback from the server on whether the action was applied, denied, or requires follow-up.

> **This command must be sent over UDP.**

***

## Client -> Server

### Context

The client sends a real-time input event.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `01101` | `000000010` |

### Example:

Body length = `2` -> `000000010`

**Raw header bytes:** `0x5A 0x02`

*(Binary: `01 01101 000000010` - `01011010 00000010`)*

### Body

| Size (bytes) |   Type  | Content                         |
| :----------: | :-----: | :------------------------------ |
|       1      | `uint8` | Key ID                          |
|      1/8     |  `bool` | Action (`1`=press, `0`=release) |

***

## Server -> Client

### Context

The server responds with execution status:

* `FAILED`: unotorized / input
* `SUCESS`: action processed
* `LATER`: action sucess, but handeled in a future command (e.g., will send `MOVE` later)

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01101` | `000000010` |

### Example (key\_id = 5, press, status = `LATER`):

Body length = `2` - `000000010`

**Raw header bytes:** `0x1A 0x02`

*(Binary: `00 01101 000000010` - `00011010 00000010`)*

### Body

| Size (bytes) |   Type  | Content                                             |
| :----------: | :-----: | :-------------------------------------------------- |
|       1      | `uint8` | Key ID (echoed)                                     |
|      1/8     |  `bool` | Action (echoed)                                     |
|      2/8     |  `enum` | Status (`00`=`FAILED`, `01`=`SUCESS`, `10`=`LATER`) |


# 0x0E - Move



# Move (ID 14)

This command is sent by the server to notify a client of a player's updated position in 3D space. Positions are encoded as 16-bit signed integers scaled by 0.01 for bandwidth efficiency.

> **This command must be sent over UDP.**

> **This command can only be sent by the server!**

***

## Server -> Client

### Context

The server broadcasts the new coordinates of a player entity after simulating movement. World positions are converted to scaled integers before transmission.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01110` | `000000111` |

### Example:

Body length = `7` -> `000000111`

**Raw header bytes:** `0x1C 0x07`

*(Binary: `00 01110 000000111` - `00011100 00000111`)*

### Body

| Size (bytes) |   Type  | Content                            |
| :----------: | :-----: | :--------------------------------- |
|       1      | `uint8` | Player ID                          |
|       2      | `int16` | X position (world = value \* 0.01) |
|       2      | `int16` | Y position (world = value \* 0.01) |
|       2      | `int16` | Z position (world = value \* 0.01) |


# 0x0F - Set position



# Set Position (ID 15)

This command is sent by the server to force an absolute position update for a player. World positions are converted to scaled integers before transmission.

> **This command must be sent over UDP.**

> **This command can only be sent by the server!**

***

## Server -> Client

### Context

The server sets a player's position to an exact location in the world, bypassing everything.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `01111` | `000000111` |

### Example:

Body length = `7` - `000000111`

**Raw header bytes:** `0x1E 0x07`

*(Binary: `00 01111 000000111` - `00011110 00000111`)*

### Body

| Size (bytes) |   Type  | Content                            |
| :----------: | :-----: | :--------------------------------- |
|       1      | `uint8` | Player ID                          |
|       2      | `int16` | X position (world = value \* 0.01) |
|       2      | `int16` | Y position (world = value \* 0.01) |
|       2      | `int16` | Z position (world = value \* 0.01) |


# 0x10 - Get coords



# Get Coords (ID 16)

This command is sent by the client to request the current position of an entity. The server responds with his positions. World positions are converted to scaled integers before transmission.

> **This command must be sent over UDP.**

***

## Client -> Server

### Context

The client requests up-to-date coordinates of an entity.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `10000` | `000000001` |

### Example:

Body length = `1` - `000000001`

**Raw header bytes:** `0x60 0x01`

*(Binary: `01 10000 000000000` - `01100000 00000001`)*

### Body

| Size (bytes) |   Type  | Content   |
| :----------: | :-----: | :-------- |
|       1      | `uint8` | Entity ID |

***

## Server -> Client

### Context

The server send the coordinates of the asked entity

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `10000` |      7      |

### Example:

Body length = `7` - `000000111`

**Raw header bytes:** `0x20 0x07`

*(Binary: `00 10000 000000111` - `00100000 00000111`)*

### Body

| Size (bytes) |   Type  | Content                           |
| :----------: | :-----: | :-------------------------------- |
|       1      | `uint8` | Entity ID (echoed)                |
|       2      | `int16` | X position (world = value Ã— 0.01) |
|       2      | `int16` | Y position (world = value Ã— 0.01) |
|       2      | `int16` | Z position (world = value Ã— 0.01) |


# 0x11 - Player Info



# Player Info (ID 17)

This command is used by the client to request information about another player. The server responds with the player's name, position, and score.

> **This command must be sent over UDP.**

***

## Client -> Server

### Context

The client requests detailed information about another player.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `10001` | `000000001` |

### Example:

Body length = `1` - `000000001`

**Raw header bytes:** `0x62 0x01`

*(Binary: `01 10001 000000001` - `01100010 00000001`)*

### Body

| Size (bytes) |   Type  | Content   |
| :----------: | :-----: | :-------- |
|       1      | `uint8` | Player ID |

***

## Server -> Client

### Context

The server sends detailed information about the requested player.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `10001` |    11+*N*   |

> Where *N* =  player name length (1 - 20).

### Example (name = "Michel", *N*=6):

Body length = `11 + 6` - `17` - `000010001`

**Raw header bytes:** `0x22 0x11`

*(Binary: `00 10001 000010001` - `00100010 00010001`)*

### Body

| Size (bytes) |   Type   | Content                            |
| :----------: | :------: | :--------------------------------- |
|       1      |  `uint8` | Player ID                          |
|      *N*     | `string` | Player name                        |
|       2      |  `int16` | X position (world = value \* 0.01) |
|       2      |  `int16` | Y position (world = value \* 0.01) |
|       2      |  `int16` | Z position (world = value \* 0.01) |
|       4      | `uint32` | Score                              |


# 0x12 - Damage



# Damage (ID 18)

This command is sent by the server to notify clients that an entity has taken damage.

> **This command must be sent over UDP.**

> **This command can only be sent by the server!**

***

## Server -> Client

### Context

The server broadcasts a damage event (e.g., player hit by enemy fire).

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `10010` |      7      |

### Example:

Body length = `7` - `000000111`

**Raw header bytes:** `0x24 0x07`

*(Binary: `00 10010 000000111` - `00100100 00000111`)*

### Body

| Size (bytes) |   Type   | Content                               |
| :----------: | :------: | :------------------------------------ |
|       2      | `uint16` | Victim ID                             |
|      1/8     |  `bool`  | Victim type (`1` = player, `0` = NPC) |
|       2      | `uint16` | Source ID                             |
|      1/8     |  `bool`  | Source type (`1` = player, `0` = NPC) |
|       2      | `uint16` | Damage amount                         |


# 0x13 - Ability



# Ability (ID 19)

This command is sent by the server to notify clients that an entity has used an ability.

> **This command must be sent over UDP.**

> **This command can only be sent by the server!**

***

## Server -> Client

### Context

The server broadcasts an ability usage event

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `10011` |      5      |

### Example:

Body length = `3` - `000000101`

**Raw header bytes:** `0x26 0x05`

*(Binary: `00 10011 000000011` - `00100110 00000101`)*

### Body

| Size (bytes) |   Type   | Content                               |
| :----------: | :------: | :------------------------------------ |
|       2      | `uint16` | Entity ID                             |
|      1/8     |  `bool`  | Entity type (`1` = player, `0` = NPC) |
|       2      | `uint16` | Ability ID                            |


# 0x14 - Score



# Score (ID 20)

This command is sent by the server to notify clients of a player's updated score.

> **This command must be sent over UDP.**

> **This command can only be sent by the server!**

***

## Server -> Client

### Context

The server broadcasts a score update

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `10100` |     `6`     |

### Example:

Body length = `7` - `000000110`

**Raw header bytes:** `0x28 0x06`
*(Binary: `00 10100 000000111` - `00101000 00000110`)*

### Body

| Size (bytes) |   Type   | Content   |
| :----------: | :------: | :-------- |
|       2      | `uint16` | Entity ID |
|       4      | `uint32` | Score     |


# 0x15 - Message



# Message (ID 21)

This command is used to send and broadcast text messages. The client sends a message to the server, and the server rebroadcasts it to all clients.

> **This command must be sent over UDP.**

***

## Client -> Server

### Context

The client sends a chat message or request to the server.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `01`   | `10101` |     *N*     |

> Where *N* = message length (1-127 bytes).

### Example (message = "Hello", L=5):

Body length = `5` - `000000101`

**Raw header bytes:** `0x6A 0x05`

*(Binary: `01 10101 000000101` - `01101010 00000101`)*

### Body

| Size (bytes) |   Type   | Content      |
| :----------: | :------: | :----------- |
|      *N*     | `string` | Message text |

***

## Server -> Client

### Context

The server broadcasts a message received from a client or generated internally.

### Header

| Direction |   Code  | Body Length |
| :-------: | :-----: | :---------: |
|    `00`   | `10101` |    3+*N*    |

> Where *N* = message length (1â€“127 bytes).

### Example (player 42 says "EZ u noob", L=3):

Body length = `9` - `000001001`

**Raw header bytes:** `0x2A 0x06`

*(Binary: `00 10101 000001001` - `00101010 00001001`)*

### Body

| Size (bytes) |   Type   | Content                                      |
| :----------: | :------: | :------------------------------------------- |
|       2      | `uint16` | Entity ID (`0` = system)                     |
|      1/8     |  `bool`  | Entity type (`1` = player, `0` = NPC/system) |
|      *N*     | `string` | Message text                                 |
