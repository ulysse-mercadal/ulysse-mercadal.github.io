---
title: Add an object
description: Add an object to the scene using the asset controller
---

Adds a 3D model to the scene and returns a unique instance ID for transformation, animation, or removal.
This method is part of the **`AssetController`**, accessible via `Renderer3D::getAssetController()`.

---

## Signature

```cpp
int AssetController::addObject(
    const std::string& filepath,
    const glm::vec3& position = glm::vec3(0.0f),
    const glm::vec3& rotation = glm::vec3(0.0f),
    const glm::vec3& scale = glm::vec3(1.0f)
);
```

To call it from your `Renderer3D` instance:

```cpp
int id = renderer.getAssetController().addObject("path/to/indien-qui-danse.fbx", position, rotation, scale);
```

---

## Parameters

| Parameter   | Type               | Description |
|-------------|--------------------|-------------|
| `filepath`  | `const std::string&` | Path to the model file (supports `.obj` and `.fbx`). Relative to the working directory. |
| `position`  | `glm::vec3`        | World-space position of the object (default: origin). |
| `rotation`  | `glm::vec3`        | Euler rotation in **degrees** (not radians). Converted internally if needed. |
| `scale`     | `glm::vec3`        | Local scale (default: uniform scale of 1). |

> The rotation is interpreted as **degrees** (consistent with many 3D tools and your current usage, e.g., `glm::radians(90.0f)` in examples).

> Internally, it may be converted to radians depending on how your `Transform` class stores it.

---

## Return Value

- **`int ≥ 0`**: The index of the new instance **within its model’s instance list**.
- **`-1`**: If the renderer is not initialized, the file extension is unsupported, or model parsing fails.

> This ID is **not globally unique**. To uniquely identify an object, you must pair it with its **model cache key** (i.e., the `filepath`). This design supports an ECS-like approach where `(modelPath, instanceId)` forms a composite key.

---

## Behavior

1. **Caching**:
   If the model at `filepath` hasn’t been loaded:
   - It is parsed using `ObjParser` (`.obj`) or `FbxParser` (`.fbx`),
   - Vertex, material, and (if present) bone data are extracted,
   - GPU buffers (VAO/VBO) are created,
   - A `Cache` object is stored in `_modelCache` under the file path.

2. **Instancing**:
   A new `InstanceData` is added to the cache’s instance list, containing:
   - A `Transform` built from `position`, `rotation`, and `scale`,
   - Default `materialIndex = 0`.

3. **Animation (FBX only)**:
   If the model contains skinning and animations:
   - A new `Animator` is created,
   - The **first animation** is played automatically,
   - The animator is stored in `Renderer3D::_animators` using the **instance ID as key**.

---

## Examples

### Load a static OBJ model
```cpp
Renderer3D renderer;
renderer.initialize();

int id = renderer.getAssetController().addObject(
    "assets/cube.obj",
    {0, 0, -5}
);

if (id == -1) {
    // Handle loading error
}
```

### Load an animated FBX character
```cpp
int dancerId = renderer.getAssetController().addObject(
    "assets/indien-qui-danse.fbx",
    {2.0f, 0.0f, -3.0f},
    {0.0f, 90.0f, 0.0f},   // Y-axis rotation in degrees
    {1.5f, 1.5f, 1.5f}
); // If the FBX file contains animations, the first one starts playing automatically.
```

---

## See Also

- **`removeAllObjects()`** – Clear all loaded models and instances.
  ```cpp
  void AssetController::removeAllObjects();
  ```
- **`getObjectCount()`** – Get total number of object instances in the scene.
  ```cpp
  size_t AssetController::getObjectCount() const;
  ```
- **`Renderer3D::getAssetController()`** – Access the asset controller from the main renderer.
  ```cpp
  AssetController& Renderer3D::getAssetController();
  ```

> To render the object, ensure at least one shader is loaded and bound via the **shader pipeline**. See the *Shader Pipeline* documentation for details.
